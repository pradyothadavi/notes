{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Notes \u00b6","title":"Home"},{"location":"#notes","text":"","title":"Notes"},{"location":"api_design/design_classes/","text":"Design Classes \u00b6 Minimize mutability By default classes should be made immutable unless there is a good reason to do otherwise If mutable, keep the state-space small and well-defined Subclass only when it makes sense Guiding Principle: If its is-a relationship then subclass else composition. Public classes should not subclass other public classes Design and Document for Inheritance or Else Prohibit it Conservative policy: all concrete classes must be final","title":"Class Design"},{"location":"api_design/design_classes/#design-classes","text":"Minimize mutability By default classes should be made immutable unless there is a good reason to do otherwise If mutable, keep the state-space small and well-defined Subclass only when it makes sense Guiding Principle: If its is-a relationship then subclass else composition. Public classes should not subclass other public classes Design and Document for Inheritance or Else Prohibit it Conservative policy: all concrete classes must be final","title":"Design Classes"},{"location":"api_design/general_principles/","text":"General Principles \u00b6 API Should Do One Thing and Do it well API Should Be As Small As Possible But No Smaller When in doubt leave it out. Because you can always add, but you can never remove. Conceptual Weight Power to Weight Ratio Implementation Should Not Impact API Dont let the implementation details leak into the API Eg: Throwing an SQL Exception. This should be consumed in the implementation details Minimize Accessibility of Everything - private is better than protected is better than public - Making private maximizes information hiding which helps modules to be redesigned easily Names Matter : API is a little language Be consistent. Eg: Remove/Delete Documentation Matters Document Religiously that is public class : a simple noun phrase methods : precondition, postcondition and side effects parameters : mention units if any Performance Consequences of API Design Decisions API Must Coexist Peacefully with Platform Don't Transliterate the API Taking advantage of underlying constructs","title":"General Principles"},{"location":"api_design/general_principles/#general-principles","text":"API Should Do One Thing and Do it well API Should Be As Small As Possible But No Smaller When in doubt leave it out. Because you can always add, but you can never remove. Conceptual Weight Power to Weight Ratio Implementation Should Not Impact API Dont let the implementation details leak into the API Eg: Throwing an SQL Exception. This should be consumed in the implementation details Minimize Accessibility of Everything - private is better than protected is better than public - Making private maximizes information hiding which helps modules to be redesigned easily Names Matter : API is a little language Be consistent. Eg: Remove/Delete Documentation Matters Document Religiously that is public class : a simple noun phrase methods : precondition, postcondition and side effects parameters : mention units if any Performance Consequences of API Design Decisions API Must Coexist Peacefully with Platform Don't Transliterate the API Taking advantage of underlying constructs","title":"General Principles"},{"location":"api_design/process/","text":"Process of API Design \u00b6 Characteristics of a Good API \u00b6 Easy to learn Easy to use, even without documentation Hard to misuse Easy to read and maintain code that uses it Sufficiently powerful to satisfy requirements Easy to extend Appropriate to audience Gather Requirements \u00b6 Your responsibility to get the true requirements Understand the use-cases. Prepare a list of tasks that the API needs to be preform in order to be successful. More rewarding to build something generic, however be mindful not to over engineer. Write a One Page Spec \u00b6 Write to your API \u00b6 These will later form your validate test cases Service Provider Interface ( SPI ) \u00b6 Test the interface for atleast 3 sources ( Will Tracz - Rules of Threes ) Eg: An SPI for an object model to persist must be tested against InMemory, SQL and Document Store Maintain Realistic Expectations \u00b6 Displease everyone at the same level as against pleasing some one specifically.","title":"Process"},{"location":"api_design/process/#process-of-api-design","text":"","title":"Process of API Design"},{"location":"api_design/process/#characteristics-of-a-good-api","text":"Easy to learn Easy to use, even without documentation Hard to misuse Easy to read and maintain code that uses it Sufficiently powerful to satisfy requirements Easy to extend Appropriate to audience","title":"Characteristics of a Good API"},{"location":"api_design/process/#gather-requirements","text":"Your responsibility to get the true requirements Understand the use-cases. Prepare a list of tasks that the API needs to be preform in order to be successful. More rewarding to build something generic, however be mindful not to over engineer.","title":"Gather Requirements"},{"location":"api_design/process/#write-a-one-page-spec","text":"","title":"Write a One Page Spec"},{"location":"api_design/process/#write-to-your-api","text":"These will later form your validate test cases","title":"Write to your API"},{"location":"api_design/process/#service-provider-interface-spi","text":"Test the interface for atleast 3 sources ( Will Tracz - Rules of Threes ) Eg: An SPI for an object model to persist must be tested against InMemory, SQL and Document Store","title":"Service Provider Interface ( SPI )"},{"location":"api_design/process/#maintain-realistic-expectations","text":"Displease everyone at the same level as against pleasing some one specifically.","title":"Maintain Realistic Expectations"},{"location":"ddia_notes/ch-01/","text":"Chapter 01 \u00b6 Reliability \u00b6 Fault and failure are not the same. Fault: is usually defined as one component of the system deviating from its spec. Failure: is when the system as a whole stops providing the required service to the user. There are different type of faults Hardware fault Software errors Human errors Scalability \u00b6 The ability to cope up with increased load. Describe Load \u00b6 Determine the load parameter(s) that best describe your system. Eg: The distribution of followers per user (maybe weighted by how often those users tweet) is a key load parameter for discussing scalability, since it determines the fan-out load Describe Performance \u00b6 When you increase a load parameter and keep the system resources (CPU, memory, network bandwidth, etc.) unchanged, how is the performance of your system affected? When you increase a load parameter, how much do you need to increase the resources if you want to keep performance unchanged? Latency Time: is the duration that a request is waiting to be handled. Service Time: is the time taken to process the request Response Time: is the time seen by the client. ( includes but not limited to service time, network and queueing delays) Maintainability \u00b6 Operability \u00b6 Runbook Useful scripts Simplicity \u00b6 Documentation Accidental complexity: a complexity that is not inherent to the problem statement that the application is solving, but arises only from the implementation. Abstraction is one of the best tool to remove accidental complexity Evolvability \u00b6 Agile methodology Test Driven Developement (TDD) Must Reads \u00b6 Chaos Monkey","title":"Chapter 01"},{"location":"ddia_notes/ch-01/#chapter-01","text":"","title":"Chapter 01"},{"location":"ddia_notes/ch-01/#reliability","text":"Fault and failure are not the same. Fault: is usually defined as one component of the system deviating from its spec. Failure: is when the system as a whole stops providing the required service to the user. There are different type of faults Hardware fault Software errors Human errors","title":"Reliability"},{"location":"ddia_notes/ch-01/#scalability","text":"The ability to cope up with increased load.","title":"Scalability"},{"location":"ddia_notes/ch-01/#describe-load","text":"Determine the load parameter(s) that best describe your system. Eg: The distribution of followers per user (maybe weighted by how often those users tweet) is a key load parameter for discussing scalability, since it determines the fan-out load","title":"Describe Load"},{"location":"ddia_notes/ch-01/#describe-performance","text":"When you increase a load parameter and keep the system resources (CPU, memory, network bandwidth, etc.) unchanged, how is the performance of your system affected? When you increase a load parameter, how much do you need to increase the resources if you want to keep performance unchanged? Latency Time: is the duration that a request is waiting to be handled. Service Time: is the time taken to process the request Response Time: is the time seen by the client. ( includes but not limited to service time, network and queueing delays)","title":"Describe Performance"},{"location":"ddia_notes/ch-01/#maintainability","text":"","title":"Maintainability"},{"location":"ddia_notes/ch-01/#operability","text":"Runbook Useful scripts","title":"Operability"},{"location":"ddia_notes/ch-01/#simplicity","text":"Documentation Accidental complexity: a complexity that is not inherent to the problem statement that the application is solving, but arises only from the implementation. Abstraction is one of the best tool to remove accidental complexity","title":"Simplicity"},{"location":"ddia_notes/ch-01/#evolvability","text":"Agile methodology Test Driven Developement (TDD)","title":"Evolvability"},{"location":"ddia_notes/ch-01/#must-reads","text":"Chaos Monkey","title":"Must Reads"},{"location":"ddia_notes/ch-02/","text":"Chapter 02 \u00b6 Each layer hides the complexity of the layers below it by providing a clean data model. Data model has such a profound effect on what the software above it can and can\u2019t do, it\u2019s important to choose one that is appropriate to the application. ## Relational Model Data is organized into relations (called tables in SQL), where each relation is an unordered collection of tuples (rows in SQL).","title":"Chapter 02"},{"location":"ddia_notes/ch-02/#chapter-02","text":"Each layer hides the complexity of the layers below it by providing a clean data model. Data model has such a profound effect on what the software above it can and can\u2019t do, it\u2019s important to choose one that is appropriate to the application. ## Relational Model Data is organized into relations (called tables in SQL), where each relation is an unordered collection of tuples (rows in SQL).","title":"Chapter 02"},{"location":"kubernetes/intro/","text":"Kuberbetes Introduction \u00b6 Kuberbetes: Greek word - captain of the ship","title":"Introduction"},{"location":"kubernetes/intro/#kuberbetes-introduction","text":"Kuberbetes: Greek word - captain of the ship","title":"Kuberbetes Introduction"},{"location":"protocol_buffers/enums/","text":"Enums in proto \u00b6 enums/feature_category.proto:10:3: Note that enum values use C++ scoping rules, meaning that enum values are siblings of their type, not children of it. Therefore, \"NOT_DEFINED\" must be unique within \"enums\", not just within \"FeatureCategory\". syntax = \"proto3\" ; package enums ; enum First { NOT_DEFINED = 0 ; F1 = 1 ; F2 = 2 ; } syntax = \"proto3\" ; package enums ; enum Second { NOT_DEFINED = 0 ; S1 = 1 ; S2 = 2 ; }","title":"Enums"},{"location":"protocol_buffers/enums/#enums-in-proto","text":"enums/feature_category.proto:10:3: Note that enum values use C++ scoping rules, meaning that enum values are siblings of their type, not children of it. Therefore, \"NOT_DEFINED\" must be unique within \"enums\", not just within \"FeatureCategory\". syntax = \"proto3\" ; package enums ; enum First { NOT_DEFINED = 0 ; F1 = 1 ; F2 = 2 ; } syntax = \"proto3\" ; package enums ; enum Second { NOT_DEFINED = 0 ; S1 = 1 ; S2 = 2 ; }","title":"Enums in proto"}]}