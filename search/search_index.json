{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Notes \u00b6","title":"Home"},{"location":"#notes","text":"","title":"Notes"},{"location":"api_design/design_classes/","text":"Design Classes \u00b6 Minimize mutability By default classes should be made immutable unless there is a good reason to do otherwise If mutable, keep the state-space small and well-defined Subclass only when it makes sense Guiding Principle: If its is-a relationship then subclass else composition. Public classes should not subclass other public classes Design and Document for Inheritance or Else Prohibit it Conservative policy: all concrete classes must be final","title":"Class Design"},{"location":"api_design/design_classes/#design-classes","text":"Minimize mutability By default classes should be made immutable unless there is a good reason to do otherwise If mutable, keep the state-space small and well-defined Subclass only when it makes sense Guiding Principle: If its is-a relationship then subclass else composition. Public classes should not subclass other public classes Design and Document for Inheritance or Else Prohibit it Conservative policy: all concrete classes must be final","title":"Design Classes"},{"location":"api_design/general_principles/","text":"General Principles \u00b6 API Should Do One Thing and Do it well API Should Be As Small As Possible But No Smaller When in doubt leave it out. Because you can always add, but you can never remove. Conceptual Weight Power to Weight Ratio Implementation Should Not Impact API Dont let the implementation details leak into the API Eg: Throwing an SQL Exception. This should be consumed in the implementation details Minimize Accessibility of Everything - private is better than protected is better than public - Making private maximizes information hiding which helps modules to be redesigned easily Names Matter : API is a little language Be consistent. Eg: Remove/Delete Documentation Matters Document Religiously that is public class : a simple noun phrase methods : precondition, postcondition and side effects parameters : mention units if any Performance Consequences of API Design Decisions API Must Coexist Peacefully with Platform Don't Transliterate the API Taking advantage of underlying constructs","title":"General Principles"},{"location":"api_design/general_principles/#general-principles","text":"API Should Do One Thing and Do it well API Should Be As Small As Possible But No Smaller When in doubt leave it out. Because you can always add, but you can never remove. Conceptual Weight Power to Weight Ratio Implementation Should Not Impact API Dont let the implementation details leak into the API Eg: Throwing an SQL Exception. This should be consumed in the implementation details Minimize Accessibility of Everything - private is better than protected is better than public - Making private maximizes information hiding which helps modules to be redesigned easily Names Matter : API is a little language Be consistent. Eg: Remove/Delete Documentation Matters Document Religiously that is public class : a simple noun phrase methods : precondition, postcondition and side effects parameters : mention units if any Performance Consequences of API Design Decisions API Must Coexist Peacefully with Platform Don't Transliterate the API Taking advantage of underlying constructs","title":"General Principles"},{"location":"api_design/process/","text":"Process of API Design \u00b6 Characteristics of a Good API \u00b6 Easy to learn Easy to use, even without documentation Hard to misuse Easy to read and maintain code that uses it Sufficiently powerful to satisfy requirements Easy to extend Appropriate to audience Gather Requirements \u00b6 Your responsibility to get the true requirements Understand the use-cases. Prepare a list of tasks that the API needs to be preform in order to be successful. More rewarding to build something generic, however be mindful not to over engineer. Write a One Page Spec \u00b6 Write to your API \u00b6 These will later form your validate test cases Service Provider Interface ( SPI ) \u00b6 Test the interface for atleast 3 sources ( Will Tracz - Rules of Threes ) Eg: An SPI for an object model to persist must be tested against InMemory, SQL and Document Store Maintain Realistic Expectations \u00b6 Displease everyone at the same level as against pleasing some one specifically.","title":"Process"},{"location":"api_design/process/#process-of-api-design","text":"","title":"Process of API Design"},{"location":"api_design/process/#characteristics-of-a-good-api","text":"Easy to learn Easy to use, even without documentation Hard to misuse Easy to read and maintain code that uses it Sufficiently powerful to satisfy requirements Easy to extend Appropriate to audience","title":"Characteristics of a Good API"},{"location":"api_design/process/#gather-requirements","text":"Your responsibility to get the true requirements Understand the use-cases. Prepare a list of tasks that the API needs to be preform in order to be successful. More rewarding to build something generic, however be mindful not to over engineer.","title":"Gather Requirements"},{"location":"api_design/process/#write-a-one-page-spec","text":"","title":"Write a One Page Spec"},{"location":"api_design/process/#write-to-your-api","text":"These will later form your validate test cases","title":"Write to your API"},{"location":"api_design/process/#service-provider-interface-spi","text":"Test the interface for atleast 3 sources ( Will Tracz - Rules of Threes ) Eg: An SPI for an object model to persist must be tested against InMemory, SQL and Document Store","title":"Service Provider Interface ( SPI )"},{"location":"api_design/process/#maintain-realistic-expectations","text":"Displease everyone at the same level as against pleasing some one specifically.","title":"Maintain Realistic Expectations"},{"location":"ddia_notes/ch-01/","text":"Chapter 01 \u00b6 Reliability \u00b6 Fault and failure are not the same. Fault: is usually defined as one component of the system deviating from its spec. Failure: is when the system as a whole stops providing the required service to the user. There are different type of faults Hardware fault Software errors Human errors Scalability \u00b6 The ability to cope up with increased load. Describe Load \u00b6 Determine the load parameter(s) that best describe your system. Eg: The distribution of followers per user (maybe weighted by how often those users tweet) is a key load parameter for discussing scalability, since it determines the fan-out load Describe Performance \u00b6 When you increase a load parameter and keep the system resources (CPU, memory, network bandwidth, etc.) unchanged, how is the performance of your system affected? When you increase a load parameter, how much do you need to increase the resources if you want to keep performance unchanged? Latency Time: is the duration that a request is waiting to be handled. Service Time: is the time taken to process the request Response Time: is the time seen by the client. ( includes but not limited to service time, network and queueing delays) Maintainability \u00b6 Operability \u00b6 Runbook Useful scripts Simplicity \u00b6 Documentation Accidental complexity: a complexity that is not inherent to the problem statement that the application is solving, but arises only from the implementation. Abstraction is one of the best tool to remove accidental complexity Evolvability \u00b6 Agile methodology Test Driven Developement (TDD) Must Reads \u00b6 Chaos Monkey","title":"Chapter 01"},{"location":"ddia_notes/ch-01/#chapter-01","text":"","title":"Chapter 01"},{"location":"ddia_notes/ch-01/#reliability","text":"Fault and failure are not the same. Fault: is usually defined as one component of the system deviating from its spec. Failure: is when the system as a whole stops providing the required service to the user. There are different type of faults Hardware fault Software errors Human errors","title":"Reliability"},{"location":"ddia_notes/ch-01/#scalability","text":"The ability to cope up with increased load.","title":"Scalability"},{"location":"ddia_notes/ch-01/#describe-load","text":"Determine the load parameter(s) that best describe your system. Eg: The distribution of followers per user (maybe weighted by how often those users tweet) is a key load parameter for discussing scalability, since it determines the fan-out load","title":"Describe Load"},{"location":"ddia_notes/ch-01/#describe-performance","text":"When you increase a load parameter and keep the system resources (CPU, memory, network bandwidth, etc.) unchanged, how is the performance of your system affected? When you increase a load parameter, how much do you need to increase the resources if you want to keep performance unchanged? Latency Time: is the duration that a request is waiting to be handled. Service Time: is the time taken to process the request Response Time: is the time seen by the client. ( includes but not limited to service time, network and queueing delays)","title":"Describe Performance"},{"location":"ddia_notes/ch-01/#maintainability","text":"","title":"Maintainability"},{"location":"ddia_notes/ch-01/#operability","text":"Runbook Useful scripts","title":"Operability"},{"location":"ddia_notes/ch-01/#simplicity","text":"Documentation Accidental complexity: a complexity that is not inherent to the problem statement that the application is solving, but arises only from the implementation. Abstraction is one of the best tool to remove accidental complexity","title":"Simplicity"},{"location":"ddia_notes/ch-01/#evolvability","text":"Agile methodology Test Driven Developement (TDD)","title":"Evolvability"},{"location":"ddia_notes/ch-01/#must-reads","text":"Chaos Monkey","title":"Must Reads"},{"location":"ddia_notes/ch-02/","text":"Chapter 02 \u00b6 Each layer hides the complexity of the layers below it by providing a clean data model. Data model has such a profound effect on what the software above it can and can\u2019t do, it\u2019s important to choose one that is appropriate to the application. ## Relational Model Data is organized into relations (called tables in SQL), where each relation is an unordered collection of tuples (rows in SQL).","title":"Chapter 02"},{"location":"ddia_notes/ch-02/#chapter-02","text":"Each layer hides the complexity of the layers below it by providing a clean data model. Data model has such a profound effect on what the software above it can and can\u2019t do, it\u2019s important to choose one that is appropriate to the application. ## Relational Model Data is organized into relations (called tables in SQL), where each relation is an unordered collection of tuples (rows in SQL).","title":"Chapter 02"},{"location":"hbase/client_api_basic/","text":"Client API : Basic \u00b6 General Notes \u00b6 The primary client interface to HBase is the HTable class. All operations that mutate data are guaranteed to be atomic on a per-row basis. This affects all other concurrent readers and writers of that same row. In other words, it does not matter if another client or thread is reading from or writing to the same row: they either read a consistent last mutation, or may have to wait before being able to apply their change. Each instantiation involves scanning the .META. table to check if the table actually exists and if it is enabled, as well as a few other operations that make this call quite costly. Therefore, it is recommended that you create HTable instances only once\u2014and one per thread\u2014and reuse that instance for the rest of the lifetime of your client application. CRUD Operations \u00b6 PUT Method \u00b6","title":"Client API Basic"},{"location":"hbase/client_api_basic/#client-api-basic","text":"","title":"Client API : Basic"},{"location":"hbase/client_api_basic/#general-notes","text":"The primary client interface to HBase is the HTable class. All operations that mutate data are guaranteed to be atomic on a per-row basis. This affects all other concurrent readers and writers of that same row. In other words, it does not matter if another client or thread is reading from or writing to the same row: they either read a consistent last mutation, or may have to wait before being able to apply their change. Each instantiation involves scanning the .META. table to check if the table actually exists and if it is enabled, as well as a few other operations that make this call quite costly. Therefore, it is recommended that you create HTable instances only once\u2014and one per thread\u2014and reuse that instance for the rest of the lifetime of your client application.","title":"General Notes"},{"location":"hbase/client_api_basic/#crud-operations","text":"","title":"CRUD Operations"},{"location":"hbase/client_api_basic/#put-method","text":"","title":"PUT Method"},{"location":"hbase/definitive_guide/","text":"Introduction \u00b6 Codd's 12 Rules The reason to store values on a per-column basis instead is based on the assumption that, for specific queries, not all of the values are needed. HBase is not a column-oriented database in the typical RDBMS sense, but utilizes an on-disk column storage format. This is also where the majority of similarities end, because although HBase stores data on disk in a column-oriented format, it is distinctly different from traditional columnar databases: whereas columnar databases excel at providing real-time analytical access to data, HBase excels at providing key-based access to a specific cell of data, or a sequential range of cells. Nonrelational Database Systems, Not-Only SQL or NoSQL? \u00b6 Dimensions \u00b6 Data model Storage model Consistency model Physical model Read/write performance Secondary indexes Failure handling Compression Load balancing Atmoic read-modify-write Locking, waits, and deadlocks DATABASE (DE-)NORMALIZATION \u00b6 At scale, it is often a requirement that we design schema differently, and a good term to describe this principle is Denormalization, Duplication, and Intelligent Keys (DDI). Building Blocks \u00b6 The most basic unit is a column. One or more columns form a row that is addressed uniquely by a row key. A number of rows, in turn, form a table, and there can be many of them. Each column may have multiple versions, with each distinct value contained in a separate cell. All columns in a column family are stored together in the same low-level storage file, called an HFile. Every column value, or cell, either is timestamped implicitly by the system or can be set explicitly by the user. Different versions of a cell are stored in decreasing timestamp order, allowing you to read the newest value first. SortedMap >>> Access to row data is atomic and includes any number of columns being read or written to. There is no further guarantee or transactional feature that spans multiple rows or across tables. Auto Sharding \u00b6 Each region is served by exactly one region server, and each of these servers can serve many regions at any time. Storage API \u00b6 The API offers operations to create and delete tables and column families. In addition, it has functions to change the table and column family metadata, such as compression or block sizes. Furthermore, there are the usual operations for clients to create or delete values as well as retrieving them with a given row key. There is also the option to run client-supplied code in the address space of the server. The server-side framework to support this is called coprocessors. The code has access to the server local data and can be used to implement lightweight batch jobs, or use expressions to analyze or summarize data based on a variety of operators. Implementation \u00b6","title":"Introduction"},{"location":"hbase/definitive_guide/#introduction","text":"Codd's 12 Rules The reason to store values on a per-column basis instead is based on the assumption that, for specific queries, not all of the values are needed. HBase is not a column-oriented database in the typical RDBMS sense, but utilizes an on-disk column storage format. This is also where the majority of similarities end, because although HBase stores data on disk in a column-oriented format, it is distinctly different from traditional columnar databases: whereas columnar databases excel at providing real-time analytical access to data, HBase excels at providing key-based access to a specific cell of data, or a sequential range of cells.","title":"Introduction"},{"location":"hbase/definitive_guide/#nonrelational-database-systems-not-only-sql-or-nosql","text":"","title":"Nonrelational Database Systems, Not-Only SQL or NoSQL?"},{"location":"hbase/definitive_guide/#dimensions","text":"Data model Storage model Consistency model Physical model Read/write performance Secondary indexes Failure handling Compression Load balancing Atmoic read-modify-write Locking, waits, and deadlocks","title":"Dimensions"},{"location":"hbase/definitive_guide/#database-de-normalization","text":"At scale, it is often a requirement that we design schema differently, and a good term to describe this principle is Denormalization, Duplication, and Intelligent Keys (DDI).","title":"DATABASE (DE-)NORMALIZATION"},{"location":"hbase/definitive_guide/#building-blocks","text":"The most basic unit is a column. One or more columns form a row that is addressed uniquely by a row key. A number of rows, in turn, form a table, and there can be many of them. Each column may have multiple versions, with each distinct value contained in a separate cell. All columns in a column family are stored together in the same low-level storage file, called an HFile. Every column value, or cell, either is timestamped implicitly by the system or can be set explicitly by the user. Different versions of a cell are stored in decreasing timestamp order, allowing you to read the newest value first. SortedMap >>> Access to row data is atomic and includes any number of columns being read or written to. There is no further guarantee or transactional feature that spans multiple rows or across tables.","title":"Building Blocks"},{"location":"hbase/definitive_guide/#auto-sharding","text":"Each region is served by exactly one region server, and each of these servers can serve many regions at any time.","title":"Auto Sharding"},{"location":"hbase/definitive_guide/#storage-api","text":"The API offers operations to create and delete tables and column families. In addition, it has functions to change the table and column family metadata, such as compression or block sizes. Furthermore, there are the usual operations for clients to create or delete values as well as retrieving them with a given row key. There is also the option to run client-supplied code in the address space of the server. The server-side framework to support this is called coprocessors. The code has access to the server local data and can be used to implement lightweight batch jobs, or use expressions to analyze or summarize data based on a variety of operators.","title":"Storage API"},{"location":"hbase/definitive_guide/#implementation","text":"","title":"Implementation"},{"location":"hbase/hbase_application/","text":"HBase \u00b6 HBase is a Java-based, open source, NoSQL, non-relational, column-oriented, distributed database built on top of the Hadoop Distributed Filesystem (HDFS), modeled after Google\u2019s BigTable paper. HBase was designed with availability over consistency and offers high availability of all its services with a fast and automatic failover. The ability to allow creation and usage of a flexible data model. In a column-oriented database, the system stores data tables as sparse columns of data rather than as entire rows of data. HBase Principles \u00b6 Table Format \u00b6 In HBase, you will find two different types of tables: the system tables and the user tables.Systems tables are used internally by HBase to keep track of meta information like the table\u2019s access control lists (ACLs), metadata for the tables and regions, namespaces, and so on.There should be no need for you to look at those tables.User tables are what you will create for your use cases.They will belong to the default namespace unless you create and use a specific one. Table Layout \u00b6 The HBase world uses many different words to describe different parts: rows, columns, keys, cells, values, KeyValues, timestamps, and more.To make sure we talk about the same thing, here is a clarification: a row is formed of multiple columns, all referenced by the same key.A specific column and a key are called a cell.It is possible to have multiple versions of the same cell, all differentiated by the timestamp.A cell can also be called a KeyValue pair.So a row, referenced by a key, is formed of a group of cells, each being a specific column for the given row. column families need to be defined at the table creation, there is no need to define the column names in advance. To allow a faster lookup access, keys and columns are alphabetically sorted within a table but also in memory. HBase orders the keys based on the byte values, so \u201cAA\u201d will come before \u201cBB\u201d. If you store numbers as character chains, keep in mind that \u201c1234\u201d will come before \u201c9\u201d. If you have to store numbers, then to save on space and to keep the ordering, you will need to store their byte representation. In this model, the integer 1234 will be stored as 0x00 0x00 0x04 0xD2, while 9 will be 0x00 0x00 0x00 0x09. Sorting those two values, we can see that 0x00 0x00 0x00 0x09 will come before 0x00 0x00 0x04 0xD2. Because they will be used to create files and directories in the filesystem, the table name and the column family names need to use only printable characters. Table Storage \u00b6 On a RegionServer, you will have as many memstores as you have regions multiplied by the number of column families receiving writes, all sharing the same reserved memory area. RegionServer Each region will have a start key and an end key that will define its boundaries.All this information will be stored within the files into the region but also into the hbase:meta table. Column Family A column family is an HBase-specific concept that you will not find in other RDBMS applications. The write cache memory area for a given RegionServer is shared by all the column families configured for all the regions hosted by the given host. Abusing column families will put pressure on the memstore, which will generate many small files, which in turn will generate a lot of compactions that might impact the performance. There is no technical limitation on the number of column families you can configure for a table. However, over the last three years, most of the use cases we had the chance to work on only required a single column family. Some required two column families, but each time we have seen more than two column families, it has been possible and recommended to reduce the number to improve efficiency. If your design includes more than three column families, you might want to take a deeper look at it and see if all those families are really required; most likely, they can be regrouped. If you do not have any consistency constraints between your two columns families and data will arrive into them at a different time, instead of creating two column families for a single table, you can also create two tables, each with a single column family. This strategy is useful when it comes time to decide the size of the regions. Indeed, while it was better to keep the two column families almost the same size, by splitting them accross two different tables, it is now easier to let me grow independently. Stores A store object regroups one memstore and zero or more store files (called HFiles). This is the entity that will store all the information written into the table and will also be used when data needs to be read from the table. HFiles HFiles are created when the memstores are full and must be flushed to disk. HFiles are eventually compacted together over time into bigger files. They are the HBase file format used to store table data. HFiles are composed of different types of blocks (e.g., index blocks and data blocks). HFiles are stored in HDFS, so they benefit from Hadoop persistence and replication. Blocks HFile blocks are usually between 8 KB and 1 MB, but the default size is 64 KB. Different blocks are Data block Index block Bloom filter block Trailer block Cells The \u201ckey type\u201d field represents the different possible HBase operations The maximum length for the row key plus the column family and the column qualifier is stored as four bytes and is 2^31 \u2013 1 \u2013 12 or, 2,147,483,635 (key length). The maximum length for the value is stored as four bytes and is 2^31 \u2013 1 or 2,147,483,647 (value length). The maximum length for the row key is stored as two signed bytes and is 32,767 (row length). Because it is stored in one signed byte, the maximum length for the column family is 127 (CF length). The maximum length for all the tags together is stored as two bytes and is 65,535 (tags length).","title":"HBase Application"},{"location":"hbase/hbase_application/#hbase","text":"HBase is a Java-based, open source, NoSQL, non-relational, column-oriented, distributed database built on top of the Hadoop Distributed Filesystem (HDFS), modeled after Google\u2019s BigTable paper. HBase was designed with availability over consistency and offers high availability of all its services with a fast and automatic failover. The ability to allow creation and usage of a flexible data model. In a column-oriented database, the system stores data tables as sparse columns of data rather than as entire rows of data.","title":"HBase"},{"location":"hbase/hbase_application/#hbase-principles","text":"","title":"HBase Principles"},{"location":"hbase/hbase_application/#table-format","text":"In HBase, you will find two different types of tables: the system tables and the user tables.Systems tables are used internally by HBase to keep track of meta information like the table\u2019s access control lists (ACLs), metadata for the tables and regions, namespaces, and so on.There should be no need for you to look at those tables.User tables are what you will create for your use cases.They will belong to the default namespace unless you create and use a specific one.","title":"Table Format"},{"location":"hbase/hbase_application/#table-layout","text":"The HBase world uses many different words to describe different parts: rows, columns, keys, cells, values, KeyValues, timestamps, and more.To make sure we talk about the same thing, here is a clarification: a row is formed of multiple columns, all referenced by the same key.A specific column and a key are called a cell.It is possible to have multiple versions of the same cell, all differentiated by the timestamp.A cell can also be called a KeyValue pair.So a row, referenced by a key, is formed of a group of cells, each being a specific column for the given row. column families need to be defined at the table creation, there is no need to define the column names in advance. To allow a faster lookup access, keys and columns are alphabetically sorted within a table but also in memory. HBase orders the keys based on the byte values, so \u201cAA\u201d will come before \u201cBB\u201d. If you store numbers as character chains, keep in mind that \u201c1234\u201d will come before \u201c9\u201d. If you have to store numbers, then to save on space and to keep the ordering, you will need to store their byte representation. In this model, the integer 1234 will be stored as 0x00 0x00 0x04 0xD2, while 9 will be 0x00 0x00 0x00 0x09. Sorting those two values, we can see that 0x00 0x00 0x00 0x09 will come before 0x00 0x00 0x04 0xD2. Because they will be used to create files and directories in the filesystem, the table name and the column family names need to use only printable characters.","title":"Table Layout"},{"location":"hbase/hbase_application/#table-storage","text":"On a RegionServer, you will have as many memstores as you have regions multiplied by the number of column families receiving writes, all sharing the same reserved memory area. RegionServer Each region will have a start key and an end key that will define its boundaries.All this information will be stored within the files into the region but also into the hbase:meta table. Column Family A column family is an HBase-specific concept that you will not find in other RDBMS applications. The write cache memory area for a given RegionServer is shared by all the column families configured for all the regions hosted by the given host. Abusing column families will put pressure on the memstore, which will generate many small files, which in turn will generate a lot of compactions that might impact the performance. There is no technical limitation on the number of column families you can configure for a table. However, over the last three years, most of the use cases we had the chance to work on only required a single column family. Some required two column families, but each time we have seen more than two column families, it has been possible and recommended to reduce the number to improve efficiency. If your design includes more than three column families, you might want to take a deeper look at it and see if all those families are really required; most likely, they can be regrouped. If you do not have any consistency constraints between your two columns families and data will arrive into them at a different time, instead of creating two column families for a single table, you can also create two tables, each with a single column family. This strategy is useful when it comes time to decide the size of the regions. Indeed, while it was better to keep the two column families almost the same size, by splitting them accross two different tables, it is now easier to let me grow independently. Stores A store object regroups one memstore and zero or more store files (called HFiles). This is the entity that will store all the information written into the table and will also be used when data needs to be read from the table. HFiles HFiles are created when the memstores are full and must be flushed to disk. HFiles are eventually compacted together over time into bigger files. They are the HBase file format used to store table data. HFiles are composed of different types of blocks (e.g., index blocks and data blocks). HFiles are stored in HDFS, so they benefit from Hadoop persistence and replication. Blocks HFile blocks are usually between 8 KB and 1 MB, but the default size is 64 KB. Different blocks are Data block Index block Bloom filter block Trailer block Cells The \u201ckey type\u201d field represents the different possible HBase operations The maximum length for the row key plus the column family and the column qualifier is stored as four bytes and is 2^31 \u2013 1 \u2013 12 or, 2,147,483,635 (key length). The maximum length for the value is stored as four bytes and is 2^31 \u2013 1 or 2,147,483,647 (value length). The maximum length for the row key is stored as two signed bytes and is 32,767 (row length). Because it is stored in one signed byte, the maximum length for the column family is 127 (CF length). The maximum length for all the tags together is stored as two bytes and is 65,535 (tags length).","title":"Table Storage"},{"location":"hbase/installation/","text":"Installation \u00b6 Disk \u00b6 Typically, you should have at least one core per disk, so in an eight-core server,adding six disks is good, but adding more might not be giving you optimal performance.","title":"Installation"},{"location":"hbase/installation/#installation","text":"","title":"Installation"},{"location":"hbase/installation/#disk","text":"Typically, you should have at least one core per disk, so in an eight-core server,adding six disks is good, but adding more might not be giving you optimal performance.","title":"Disk"},{"location":"kubernetes/intro/","text":"Kuberbetes Introduction \u00b6 Kuberbetes: Greek word - captain of the ship","title":"Introduction"},{"location":"kubernetes/intro/#kuberbetes-introduction","text":"Kuberbetes: Greek word - captain of the ship","title":"Kuberbetes Introduction"},{"location":"protocol_buffers/enums/","text":"Enums in proto \u00b6 enums/feature_category.proto:10:3: Note that enum values use C++ scoping rules, meaning that enum values are siblings of their type, not children of it. Therefore, \"NOT_DEFINED\" must be unique within \"enums\", not just within \"FeatureCategory\". syntax = \"proto3\" ; package enums ; enum First { NOT_DEFINED = 0 ; F1 = 1 ; F2 = 2 ; } syntax = \"proto3\" ; package enums ; enum Second { NOT_DEFINED = 0 ; S1 = 1 ; S2 = 2 ; }","title":"Enums"},{"location":"protocol_buffers/enums/#enums-in-proto","text":"enums/feature_category.proto:10:3: Note that enum values use C++ scoping rules, meaning that enum values are siblings of their type, not children of it. Therefore, \"NOT_DEFINED\" must be unique within \"enums\", not just within \"FeatureCategory\". syntax = \"proto3\" ; package enums ; enum First { NOT_DEFINED = 0 ; F1 = 1 ; F2 = 2 ; } syntax = \"proto3\" ; package enums ; enum Second { NOT_DEFINED = 0 ; S1 = 1 ; S2 = 2 ; }","title":"Enums in proto"},{"location":"zookeeper/intro/","text":"Zookeeper \u00b6 ZooKeeper is a high-performance coordination service for distributed applications.","title":"Introduction"},{"location":"zookeeper/intro/#zookeeper","text":"ZooKeeper is a high-performance coordination service for distributed applications.","title":"Zookeeper"}]}